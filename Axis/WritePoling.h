#pragma once

#include "Common/Signal/Define.h"
#include "Signal/Write.h"
#include "ResultPoling.h"

namespace Standard
{
	namespace Axis
	{
		// 軸の制御を行う情報
		namespace Write
		{
			////////////////////////////////////////////////////////////////////////////////
			/// @class      CSuper
			/// @brief      軸を制御する情報のスーパークラス
			///				⇒ 状態を監視する情報の基礎クラスから継承
			////////////////////////////////////////////////////////////////////////////////
			class CSuper
				: virtual public Signal::Write::CBasis<Result::CSuper, Axis::OnReceive>
			{
			public:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コンストラクタ
				////////////////////////////////////////////////////////////////////////////////
				CSuper() : Signal::Write::CBasis<Result::CSuper, Axis::OnReceive>()
				{

				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コピー代入演算子
				/// @return			自クラス
				////////////////////////////////////////////////////////////////////////////////
				CSuper& operator = (const CSuper& object) noexcept
				{
					// 更新
					Update(object);

					return *this;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			デストラクタ
				////////////////////////////////////////////////////////////////////////////////
				virtual ~CSuper()
				{

				}

			protected:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			自クラスを更新
				/// @param[in]		object	自クラス
				////////////////////////////////////////////////////////////////////////////////
				void Update(const CSuper& object)
				{
					// 既定の関数
					Signal::Write::CBasis<Result::CSuper, Axis::OnReceive>::Update(object);

					this->Indexs.clear();
					std::copy(object.Indexs.begin(), object.Indexs.end(), std::back_inserter(this->Indexs));
				}

			public:
				//! 使用する軸の番号
				std::vector<int> Indexs;
			};

			namespace Servo
			{
				////////////////////////////////////////////////////////////////////////////////
				/// @class      CSuper
				/// @brief      軸のサーボを制御する情報の基礎クラス
				///				⇒ 軸を制御する情報のスーパークラスから継承
				////////////////////////////////////////////////////////////////////////////////
				class CBasis
					: virtual public Write::CSuper
				{
				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					CBasis() : Write::CSuper()
					{
						Mode = Signal::StatusOff;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CBasis& operator = (const CBasis& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					virtual ~CBasis()
					{

					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const CBasis& object)
					{
						Mode = object.Mode;
					}

				public:
					//! サーボの状態
					Signal::EnumStatus Mode;
				};
			}
		}
	}
}