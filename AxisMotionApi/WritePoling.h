#pragma once

#include "Signal/Result.h"

namespace Standard
{
	namespace Axis
	{
		namespace Write
		{
			////////////////////////////////////////////////////////////////////////////////
			/// @class      CBasis
			/// @brief      軸を監視した結果の基礎クラス
			///				⇒ 軸を監視した結果のスーパークラスから継承
			////////////////////////////////////////////////////////////////////////////////
			class CBasis
				: virtual public CSuper
			{
			public:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コンストラクタ
				////////////////////////////////////////////////////////////////////////////////
				CBasis()
				{
					DeviceHandle = NULL;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コピー代入演算子
				/// @return			自クラス
				////////////////////////////////////////////////////////////////////////////////
				CBasis& operator = (const CBasis& object) noexcept
				{
					// 更新
					Update(object);

					return *this;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			デストラクタ
				////////////////////////////////////////////////////////////////////////////////
				virtual ~CBasis()
				{

				}

			protected:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			自クラスを更新
				/// @param[in]		object	自クラス
				////////////////////////////////////////////////////////////////////////////////
				void Update(const CBasis& object)
				{
					// 既定の関数
					CSuper::Update(object);

					this->DeviceHandle = object.DeviceHandle;
				}

			public:
				//! デバイスのハンドル
				unsigned long DeviceHandle;
			};

			////////////////////////////////////////////////////////////////////////////////
			/// @class      CInitialize
			/// @brief      軸の初期化を制御する情報クラス
			///				⇒ 軸を監視した結果の基礎クラスから継承
			////////////////////////////////////////////////////////////////////////////////
			class CInitialize
				: virtual public CBasis
			{
			public:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コンストラクタ
				////////////////////////////////////////////////////////////////////////////////
				CInitialize()
				{

				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コピー代入演算子
				/// @return			自クラス
				////////////////////////////////////////////////////////////////////////////////
				CInitialize& operator = (const CInitialize& object) noexcept
				{
					// 更新
					Update(object);

					return *this;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			デストラクタ
				////////////////////////////////////////////////////////////////////////////////
				virtual ~CInitialize()
				{

				}

			protected:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			自クラスを更新
				/// @param[in]		object	自クラス
				////////////////////////////////////////////////////////////////////////////////
				void Update(const CInitialize& object)
				{
					// 既定の関数
					CBasis::Update(object);
				}
			};

			////////////////////////////////////////////////////////////////////////////////
			/// @class      CDestroy
			/// @brief      軸の破棄を制御する情報クラス
			///				⇒ 軸を監視した結果の基礎クラスから継承
			////////////////////////////////////////////////////////////////////////////////
			class CDestroy
				: virtual public CBasis
			{
			public:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コンストラクタ
				////////////////////////////////////////////////////////////////////////////////
				CDestroy()
				{

				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コピー代入演算子
				/// @return			自クラス
				////////////////////////////////////////////////////////////////////////////////
				CDestroy& operator = (const CDestroy& object) noexcept
				{
					// 更新
					Update(object);

					return *this;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			デストラクタ
				////////////////////////////////////////////////////////////////////////////////
				virtual ~CDestroy()
				{

				}

			protected:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			自クラスを更新
				/// @param[in]		object	自クラス
				////////////////////////////////////////////////////////////////////////////////
				void Update(const CDestroy& object)
				{
					// 既定の関数
					CBasis::Update(object);
				}
			};

			////////////////////////////////////////////////////////////////////////////////
			/// @class      CServo
			/// @brief      軸のサーボを制御する情報クラス
			///				⇒ 軸を制御する情報の基礎クラスから継承
			////////////////////////////////////////////////////////////////////////////////
			class CServo
				: virtual public CBasis
			{
			public:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コンストラクタ
				////////////////////////////////////////////////////////////////////////////////
				CServo() : CBasis()
				{
					Mode = Signal::StatusOff;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コピー代入演算子
				/// @return			自クラス
				////////////////////////////////////////////////////////////////////////////////
				CServo& operator = (const CServo& object) noexcept
				{
					// 更新
					Update(object);

					return *this;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			デストラクタ
				////////////////////////////////////////////////////////////////////////////////
				~CServo() override
				{

				}

			protected:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			自クラスを更新
				/// @param[in]		object	自クラス
				////////////////////////////////////////////////////////////////////////////////
				void Update(const CServo& object)
				{
					// 既定の関数
					CBasis::Update(object);

					this->Mode = object.Mode;
				}

			public:
				//! サーボの状態
				Signal::EnumStatus Mode;
			};
		}
	}
}