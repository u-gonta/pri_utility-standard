#pragma once

#include <map>

#include "Common/Signal/Define.h"
#include "Common/Axis/Setting.h"
#include "Common/Iterator/Basis.h"

namespace Standard
{
	namespace Axis
	{
		namespace Status
		{
			namespace Input
			{
				////////////////////////////////////////////////////////////////////////////////
				/// @enum			座標
				////////////////////////////////////////////////////////////////////////////////
				enum EnumCoordinate
				{
					CoordinatePositiveLimit,			// 負方向ソフトリミット
					CoordinateNegativeLimit,			// 正方向ソフトリミット
					CoordinateCurrent					// 現在の座標
				};
				typedef Iterator::CWorker<EnumCoordinate, CoordinatePositiveLimit, CoordinateCurrent> CoordinateIterator;

				////////////////////////////////////////////////////////////////////////////////
				/// @class      CDriver
				/// @brief      機器の状態を保持するクラス
				////////////////////////////////////////////////////////////////////////////////
				class CDriver
				{
				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					CDriver()
					{
						Name = "";
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CDriver& operator = (const CDriver& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					~CDriver()
					{

					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const CDriver& object)
					{
						this->Name = object.Name;
						this->Running = object.Running;
						this->Warning = object.Warning;
						this->Alarm = object.Alarm;
						this->Valid = object.Valid;
						this->Position = object.Position;
						this->Coordinate = object.Coordinate;
					}

				public:
					//! 名称
					std::string Name;

					//! 運転ステータス
					std::map<unsigned short, bool> Running;

					//! ワーニング
					std::map<unsigned short, bool> Warning;

					//! アラーム
					std::map<unsigned short, bool> Alarm;

					//! 有効
					std::map<unsigned short, bool> Valid;

					//! 位置
					std::map<unsigned short, bool> Position;

					//! 座標
					std::map<unsigned short, double> Coordinate;
				};
			}

			////////////////////////////////////////////////////////////////////////////////
			/// @class      CInput
			/// @brief      軸の状態(入力)を保持するクラス
			////////////////////////////////////////////////////////////////////////////////
			class CInput
			{
			public:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コンストラクタ
				////////////////////////////////////////////////////////////////////////////////
				CInput()
				{

				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コピー代入演算子
				/// @return			自クラス
				////////////////////////////////////////////////////////////////////////////////
				CInput& operator = (const CInput& object) noexcept
				{
					// 更新
					Update(object);

					return *this;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コピー代入演算子
				/// @return			自クラス
				////////////////////////////////////////////////////////////////////////////////
				CInput& operator += (const CInput& object) noexcept
				{
					// 追加
					Insert(object);

					return *this;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			デストラクタ
				////////////////////////////////////////////////////////////////////////////////
				~CInput()
				{

				}

			protected:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			自クラスを更新
				/// @param[in]		object	自クラス
				////////////////////////////////////////////////////////////////////////////////
				void Update(const CInput& object)
				{
					this->Drivers = object.Drivers;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			自クラスを追加
				/// @param[in]		object	自クラス
				////////////////////////////////////////////////////////////////////////////////
				void Insert(const CInput& object)
				{
					for (const auto& driver : object.Drivers)
					{
						this->Drivers[driver.first].Running = driver.second.Running;
						this->Drivers[driver.first].Warning = driver.second.Warning;
						this->Drivers[driver.first].Alarm = driver.second.Alarm;
						this->Drivers[driver.first].Valid = driver.second.Valid;
						this->Drivers[driver.first].Position = driver.second.Position;
					}
				}

			public:
				//! 機器の状態を保持するクラス
				std::map<int, Input::CDriver> Drivers;
			};

			namespace Output
			{
				////////////////////////////////////////////////////////////////////////////////
				/// @class      CTemplate
				/// @brief      軸の状態(出力)を指定するテンプレートのクラス
				////////////////////////////////////////////////////////////////////////////////
				class CTemplate
				{
				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					CTemplate()
					{

					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CTemplate& operator = (const CTemplate& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					virtual ~CTemplate()
					{

					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const CTemplate& object)
					{
						this->Drivers = object.Drivers;
						this->Other = object.Other;
					}

				public:
					//! 機器の設定クラス
					std::map<int, Axis::Setting::CDriver> Drivers;

					//! その他
					Variant::CManager Other;
				};

				////////////////////////////////////////////////////////////////////////////////
				/// @class      CServo
				/// @brief      軸のサーボ状態(出力)を指定するクラス
				///				⇒ 軸の状態(出力)を指定するテンプレートのクラスから派生
				////////////////////////////////////////////////////////////////////////////////
				class CServo
					: virtual public CTemplate
				{
				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					CServo() : CTemplate()
					{
						Mode = Signal::StatusOff;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CServo& operator = (const CServo& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					~CServo()
					{

					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const CServo& object)
					{
						// 既定の関数
						CTemplate::Update(object);

						this->Mode = object.Mode;
					}

				public:
					//! 状態
					Signal::EnumStatus Mode;
				};

				////////////////////////////////////////////////////////////////////////////////
				/// @class      CStartJog
				/// @brief      軸のジョグ実行を指定するクラス
				///				⇒ 軸の状態(出力)を指定するテンプレートのクラスから派生
				////////////////////////////////////////////////////////////////////////////////
				class CStartJog
					: virtual public CTemplate
				{
				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					CStartJog() : CTemplate()
					{

					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CStartJog& operator = (const CStartJog& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					~CStartJog()
					{

					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const CStartJog& object)
					{
						// 既定の関数
						CTemplate::Update(object);
					}
				};

				////////////////////////////////////////////////////////////////////////////////
				/// @class      CStopJog
				/// @brief      軸のジョグ停止を指定するクラス
				///				⇒ 軸の状態(出力)を指定するテンプレートのクラスから派生
				////////////////////////////////////////////////////////////////////////////////
				class CStopJog
					: virtual public CTemplate
				{
				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					CStopJog() : CTemplate()
					{

					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CStopJog& operator = (const CStopJog& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					~CStopJog()
					{

					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const CStopJog& object)
					{
						// 既定の関数
						CTemplate::Update(object);
					}
				};
			}

			////////////////////////////////////////////////////////////////////////////////
			/// @class      COutput
			/// @brief      軸の状態(出力)を指定するクラス
			////////////////////////////////////////////////////////////////////////////////
			class COutput
			{
			public:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コンストラクタ
				////////////////////////////////////////////////////////////////////////////////
				COutput()
				{
					Timeout = 60000;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コピー代入演算子
				/// @return			自クラス
				////////////////////////////////////////////////////////////////////////////////
				COutput& operator = (const COutput& object) noexcept
				{
					// 更新
					Update(object);

					return *this;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			デストラクタ
				////////////////////////////////////////////////////////////////////////////////
				virtual ~COutput()
				{

				}

			protected:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			自クラスを更新
				/// @param[in]		object	自クラス
				////////////////////////////////////////////////////////////////////////////////
				void Update(const COutput& object)
				{
					this->Timeout = object.Timeout;
					this->Command = object.Command;
				}

			public:
				//! タイムアウト[ms]
				int Timeout;

				//! 制御を指定するクラス
				boost::any Command;
			};
		}
	}
}