#pragma once

#include <map>

#include "Common/Signal/Define.h"
#include "Common/Axis/Setting.h"
#include "Common/Iterator/Basis.h"

namespace Standard
{
	namespace Axis
	{
		namespace Status
		{
			namespace Input
			{
				////////////////////////////////////////////////////////////////////////////////
				/// @enum			動作
				////////////////////////////////////////////////////////////////////////////////
				enum EnumMotion
				{
					MotionAbnormal,					// 異常
					MotionServo,					// サーボON
					MotionOrigin,					// 原点復帰完了
					MotionRunning,					// 実行中
					MotionCompleted					// 実行完了
				};
				typedef Iterator::CWorker<EnumMotion, MotionServo, MotionCompleted> MotionIterator;

				////////////////////////////////////////////////////////////////////////////////
				/// @enum			座標
				////////////////////////////////////////////////////////////////////////////////
				enum EnumCoordinate
				{
					CoordinatePositiveLimit,			// 負方向ソフトリミット
					CoordinateNegativeLimit,			// 正方向ソフトリミット
					CoordinateCurrent					// 現在の座標
				};
				typedef Iterator::CWorker<EnumCoordinate, CoordinatePositiveLimit, CoordinateCurrent> CoordinateIterator;

				////////////////////////////////////////////////////////////////////////////////
				/// @class      CDriver
				/// @brief      機器の状態を保持するクラス
				////////////////////////////////////////////////////////////////////////////////
				class CDriver
				{
				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					CDriver()
					{
						Name = "";
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CDriver& operator = (const CDriver& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CDriver& operator += (const CDriver& object) noexcept
					{
						// 追加
						Insert(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					~CDriver()
					{

					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const CDriver& object)
					{
						this->Name = object.Name;
						this->Motion = object.Motion;
						this->Warning = object.Warning;
						this->Alarm = object.Alarm;
						this->Coordinate = object.Coordinate;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを追加
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Insert(const CDriver& object)
					{
						this->Name = object.Name;
						for (const auto& motion : object.Motion)
						{
							this->Motion[motion.first] = motion.second;
						}
						for (const auto& warning : object.Warning)
						{
							this->Warning[warning.first] = warning.second;
						}
						for (const auto& alarm : object.Alarm)
						{
							this->Alarm[alarm.first] = alarm.second;
						}
						for (const auto& coordinate : object.Coordinate)
						{
							this->Coordinate[coordinate.first] = coordinate.second;
						}
					}

				public:
					//! 名称
					std::string Name;

					//! 動作
					std::map<unsigned short, bool> Motion;

					//! ワーニング
					std::map<unsigned short, bool> Warning;

					//! アラーム
					std::map<unsigned short, bool> Alarm;

					//! 座標
					std::map<EnumCoordinate, double> Coordinate;
				};
			}

			////////////////////////////////////////////////////////////////////////////////
			/// @class      CInput
			/// @brief      軸の状態(入力)を保持するクラス
			////////////////////////////////////////////////////////////////////////////////
			class CInput
			{
			public:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コンストラクタ
				////////////////////////////////////////////////////////////////////////////////
				CInput()
				{

				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コピー代入演算子
				/// @return			自クラス
				////////////////////////////////////////////////////////////////////////////////
				CInput& operator = (const CInput& object) noexcept
				{
					// 更新
					Update(object);

					return *this;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コピー代入演算子
				/// @return			自クラス
				////////////////////////////////////////////////////////////////////////////////
				CInput& operator += (const CInput& object) noexcept
				{
					// 追加
					Insert(object);

					return *this;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			デストラクタ
				////////////////////////////////////////////////////////////////////////////////
				~CInput()
				{

				}

			protected:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			自クラスを更新
				/// @param[in]		object	自クラス
				////////////////////////////////////////////////////////////////////////////////
				void Update(const CInput& object)
				{
					this->Drivers.clear();
					this->Drivers = object.Drivers;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			自クラスを追加
				/// @param[in]		object	自クラス
				////////////////////////////////////////////////////////////////////////////////
				void Insert(const CInput& object)
				{
					for (const auto& driver : object.Drivers)
					{
						this->Drivers[driver.first] += driver.second;
					}
				}

			public:
				//! 機器の状態を保持するクラス
				std::map<int, Input::CDriver> Drivers;
			};

			namespace Output
			{
				////////////////////////////////////////////////////////////////////////////////
				/// @class      CTemplate
				/// @brief      軸の状態(出力)を指定するテンプレートのクラス
				////////////////////////////////////////////////////////////////////////////////
				class CTemplate
				{
				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					CTemplate()
					{

					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CTemplate& operator = (const CTemplate& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					virtual ~CTemplate()
					{

					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const CTemplate& object)
					{
						this->Drivers = object.Drivers;
						this->Other = object.Other;
					}

				public:
					//! 機器の設定クラス
					std::map<int, Axis::Setting::CDriver> Drivers;

					//! その他
					Variant::CManager Other;
				};

				////////////////////////////////////////////////////////////////////////////////
				/// @class      CSuspend
				/// @brief      制御の停止を指定するクラス
				///				⇒ 軸の状態(出力)を指定するテンプレートのクラスから派生
				////////////////////////////////////////////////////////////////////////////////
				class CSuspend
					: virtual public CTemplate
				{
				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					CSuspend() : CTemplate()
					{

					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CSuspend& operator = (const CSuspend& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					~CSuspend()
					{

					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const CSuspend& object)
					{
						// 既定の関数
						CTemplate::Update(object);
					}
				};

				////////////////////////////////////////////////////////////////////////////////
				/// @class      CServo
				/// @brief      サーボの状態を指定するクラス
				///				⇒ 軸の状態(出力)を指定するテンプレートのクラスから派生
				////////////////////////////////////////////////////////////////////////////////
				class CServo
					: virtual public CTemplate
				{
				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					CServo() : CTemplate()
					{
						Mode = Signal::StatusOff;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CServo& operator = (const CServo& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					~CServo()
					{

					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const CServo& object)
					{
						// 既定の関数
						CTemplate::Update(object);

						this->Mode = object.Mode;
					}

				public:
					//! 状態
					Signal::EnumStatus Mode;
				};

				////////////////////////////////////////////////////////////////////////////////
				/// @class      CMoveOrigin
				/// @brief      原点復帰の実行を指定するクラス
				///				⇒ 軸の状態(出力)を指定するテンプレートのクラスから派生
				////////////////////////////////////////////////////////////////////////////////
				class CMoveOrigin
					: virtual public CTemplate
				{
				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					CMoveOrigin() : CTemplate()
					{

					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CMoveOrigin& operator = (const CMoveOrigin& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					~CMoveOrigin()
					{

					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const CMoveOrigin& object)
					{
						// 既定の関数
						CTemplate::Update(object);
					}
				};

				////////////////////////////////////////////////////////////////////////////////
				/// @class      CStartJog
				/// @brief      ジョグの開始を指定するクラス
				///				⇒ 軸の状態(出力)を指定するテンプレートのクラスから派生
				////////////////////////////////////////////////////////////////////////////////
				class CStartJog
					: virtual public CTemplate
				{
				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					CStartJog() : CTemplate()
					{

					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CStartJog& operator = (const CStartJog& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					~CStartJog()
					{

					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const CStartJog& object)
					{
						// 既定の関数
						CTemplate::Update(object);
					}
				};

				////////////////////////////////////////////////////////////////////////////////
				/// @class      CStopJog
				/// @brief      ジョグの停止を指定するクラス
				///				⇒ 軸の状態(出力)を指定するテンプレートのクラスから派生
				////////////////////////////////////////////////////////////////////////////////
				class CStopJog
					: virtual public CTemplate
				{
				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					CStopJog() : CTemplate()
					{

					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CStopJog& operator = (const CStopJog& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					~CStopJog()
					{

					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const CStopJog& object)
					{
						// 既定の関数
						CTemplate::Update(object);
					}
				};
			}

			////////////////////////////////////////////////////////////////////////////////
			/// @class      COutput
			/// @brief      軸の状態(出力)を指定するクラス
			////////////////////////////////////////////////////////////////////////////////
			class COutput
			{
			public:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コンストラクタ
				////////////////////////////////////////////////////////////////////////////////
				COutput()
				{
					Timeout = 60000;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コピー代入演算子
				/// @return			自クラス
				////////////////////////////////////////////////////////////////////////////////
				COutput& operator = (const COutput& object) noexcept
				{
					// 更新
					Update(object);

					return *this;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			デストラクタ
				////////////////////////////////////////////////////////////////////////////////
				virtual ~COutput()
				{

				}

			protected:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			自クラスを更新
				/// @param[in]		object	自クラス
				////////////////////////////////////////////////////////////////////////////////
				void Update(const COutput& object)
				{
					this->Timeout = object.Timeout;
					this->Command = object.Command;
				}

			public:
				//! タイムアウト[ms]
				int Timeout;

				//! 制御を指定するクラス
				boost::any Command;
			};
		}
	}
}