#pragma once

#include <vector>
#include <map>

#include "boost/any.hpp"

#include "Common/Tool/Text.h"

namespace Standard
{
	namespace Io
	{
		namespace Specify
		{
			////////////////////////////////////////////////////////////////////////////////
			/// @class      CAddress
			/// @brief      アドレスのクラス
			////////////////////////////////////////////////////////////////////////////////
			class CAddress
			{
			public:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コンストラクタ
				////////////////////////////////////////////////////////////////////////////////
				CAddress()
				{
					Category = "";
					Index = 0;
					Hex = false;
					Margin = 5;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コピー代入演算子
				/// @return			自クラス
				////////////////////////////////////////////////////////////////////////////////
				CAddress& operator = (const CAddress& object) noexcept
				{
					// 更新
					Update(object);

					return *this;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			比較演算子
				/// @return			自クラス
				////////////////////////////////////////////////////////////////////////////////
				bool operator == (const CAddress& object) const
				{
					return std::tie(Category, Index) == std::tie(object.Category, object.Index);
				}

				//////////////////////////////////////////////////////////////////////////////////
				///// @brief			比較演算子
				///// @return			自クラス
				//////////////////////////////////////////////////////////////////////////////////
				//bool operator != (const CAddress& value) const
				//{
				//	return std::tie(Category, Index) != std::tie(value.Category, value.Index);
				//}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			比較演算子
				/// @return			自クラス
				////////////////////////////////////////////////////////////////////////////////
				bool operator < (const CAddress& object) const
				{
					return std::tie(Category, Index) < std::tie(object.Category, object.Index);
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			デストラクタ
				////////////////////////////////////////////////////////////////////////////////
				virtual ~CAddress()
				{

				}

			protected:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			自クラスを更新
				/// @param[in]		object	自クラス
				////////////////////////////////////////////////////////////////////////////////
				void Update(const CAddress& object)
				{
					this->Category = object.Category;
					this->Index = object.Index;
					this->Hex = object.Hex;
					this->Margin = object.Margin;
				}

			public:
				//! データの種別
				std::string Category;

				//! 番号
				int Index;

				//! フォーマットの型
				bool Hex;

				//! フォーマットの桁数
				int Margin;
			};

			////////////////////////////////////////////////////////////////////////////////
			/// @brief			文字列に変換
			/// @param[in]		アドレスのクラス
			/// @return			文字列に変換したアドレス
			////////////////////////////////////////////////////////////////////////////////
			inline std::string Format(const CAddress& object)
			{
				std::stringstream ret;

				// データの種別を付加
				ret << object.Category;

				// フォーマットの型を確認
				if (object.Hex)
				{
					// 16進数で変換
					ret << Text::FormatX(object.Margin, object.Index, "");
				}
				else
				{
					// 10進数で変換
					ret << Text::Format(object.Margin, object.Index);
				}

				return ret.str();
			}
		}

		namespace Status
		{
			////////////////////////////////////////////////////////////////////////////////
			/// @enum			ビットの方向
			////////////////////////////////////////////////////////////////////////////////
			enum EnumDirection
			{
				DirectionRise,		// 立ち上がり
				DirectionFall		// 立ち下がり
			};

			////////////////////////////////////////////////////////////////////////////////
			/// @class      CEntity
			/// @brief      状態を保持するクラス
			///				⇒ アドレスのクラスから派生
			////////////////////////////////////////////////////////////////////////////////
			class CEntity
				: virtual public Specify::CAddress
			{
			public:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コンストラクタ
				////////////////////////////////////////////////////////////////////////////////
				CEntity() : Specify::CAddress()
				{

				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コンストラクタ
				/// @param[in]		address	アドレスのクラス
				/// @param[in]		value	データ
				////////////////////////////////////////////////////////////////////////////////
				CEntity(const Specify::CAddress& address, const boost::any& value) : CEntity()
				{
					// 既定の関数
					Specify::CAddress::Update(address);

					this->Value = value;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コピー代入演算子
				/// @return			自クラス
				////////////////////////////////////////////////////////////////////////////////
				CEntity& operator = (const CEntity& object) noexcept
				{
					// 更新
					Update(object);

					return *this;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			デストラクタ
				////////////////////////////////////////////////////////////////////////////////
				~CEntity()
				{

				}

			protected:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			自クラスを更新
				/// @param[in]		object	自クラス
				////////////////////////////////////////////////////////////////////////////////
				void Update(const CEntity& object)
				{
					// 既定の関数
					CAddress::Update(object);

					this->Value = object.Value;
				}

			public:
				//! 値
				boost::any Value;
			};

			////////////////////////////////////////////////////////////////////////////////
			/// @class      CInput
			/// @brief      IOの状態(入力)のクラス
			////////////////////////////////////////////////////////////////////////////////
			class CInput
			{
			public:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コンストラクタ
				////////////////////////////////////////////////////////////////////////////////
				CInput()
				{

				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コピー代入演算子
				/// @return			自クラス
				////////////////////////////////////////////////////////////////////////////////
				CInput& operator = (const CInput& object) noexcept
				{
					// 更新
					Update(object);

					return *this;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コピー代入演算子
				/// @return			自クラス
				////////////////////////////////////////////////////////////////////////////////
				CInput& operator += (const CInput& object) noexcept
				{
					// 追加
					Insert(object);

					return *this;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			デストラクタ
				////////////////////////////////////////////////////////////////////////////////
				~CInput()
				{

				}

			protected:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			自クラスを更新
				/// @param[in]		object	自クラス
				////////////////////////////////////////////////////////////////////////////////
				void Update(const CInput& object)
				{
					this->Values.clear();

					// 自クラスを追加
					Insert(object);
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			自クラスを追加
				/// @param[in]		object	自クラス
				////////////////////////////////////////////////////////////////////////////////
				void Insert(const CInput& object)
				{
					for (const auto& value : object.Values)
					{
						this->Values[value.first] = value.second;
					}
				}

			public:
				//! 入力の状態
				std::map<Specify::CAddress, boost::any> Values;
			};

			////////////////////////////////////////////////////////////////////////////////
			/// @class      COutput
			/// @brief      IOの状態(出力)のクラス
			////////////////////////////////////////////////////////////////////////////////
			class COutput
			{
			public:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コンストラクタ
				////////////////////////////////////////////////////////////////////////////////
				COutput()
				{

				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			コピー代入演算子
				/// @return			自クラス
				////////////////////////////////////////////////////////////////////////////////
				COutput& operator = (const COutput& object) noexcept
				{
					// 更新
					Update(object);

					return *this;
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @brief			デストラクタ
				////////////////////////////////////////////////////////////////////////////////
				~COutput()
				{

				}

			protected:
				////////////////////////////////////////////////////////////////////////////////
				/// @brief			自クラスを更新
				/// @param[in]		object	自クラス
				////////////////////////////////////////////////////////////////////////////////
				void Update(const COutput& object)
				{
					this->Entitys.clear();
					std::copy(object.Entitys.begin(), object.Entitys.end(), std::back_inserter(this->Entitys));
				}

			public:
				//! 状態を保持するクラス
				std::vector<CEntity> Entitys;
			};
		}
	}
}