#pragma once

#include "Common/Archive/Convert.h"
#include "Identifier.h"

// 1バイトアラインメントに変更
#pragma pack(1)

namespace Standard
{
	namespace MotionApi
	{
		namespace Controller
		{
			////////////////////////////////////////////////////////////////////////////////
			/// @enum			通信の種別
			////////////////////////////////////////////////////////////////////////////////
			enum EnumDevice
			{
				DevicePci = 4,		// PCI bus (910)
				DevicePciE = 6		// PCIeバス(Mp3100)
			};

			namespace Setting
			{
				////////////////////////////////////////////////////////////////////////////////
				/// @class      COpen
				/// @brief      コントローラを開く設定クラス
				////////////////////////////////////////////////////////////////////////////////
				class COpen
				{
				private:
					//! シリアライズのタイトル
					const std::string ConstHeader = "OpenController";

				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					COpen()
					{
						Device = DevicePciE;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					COpen& operator = (const COpen& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					~COpen()
					{

					}

				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			シリアライズ
					////////////////////////////////////////////////////////////////////////////////
					friend class cereal::access;
					template<class T>
					void serialize(T& archive)
					{
						archive(cereal::make_nvp("Device", Device));
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			Json形式にシリアライズした文字列から更新
					/// @param[in]		object	Json形式にシリアライズした文字列
					////////////////////////////////////////////////////////////////////////////////
					void Input(std::string object)
					{
						// Json形式から変換
						Update(Archive::Input<COpen>(ConstHeader, object));
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			Json形式にシリアライズした文字列を取得
					/// @return			シリアライズした文字列
					////////////////////////////////////////////////////////////////////////////////
					std::string Output()
					{
						std::string ret;

						// Json形式に変換
						ret = Archive::Output<COpen>(ConstHeader, *this);

						return ret;
					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const COpen& object)
					{
						this->Device = object.Device;
					}

				public:
					//! 通信の種別
					EnumDevice Device;
				};

				////////////////////////////////////////////////////////////////////////////////
				/// @class      CApiTimeout
				/// @brief      Apiタイムアウトの設定クラス
				////////////////////////////////////////////////////////////////////////////////
				class CApiTimeout
				{
				private:
					//! シリアライズのタイトル
					const std::string ConstHeader = "ApiTimeout";

				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					CApiTimeout()
					{
						Value = -1;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CApiTimeout& operator = (const CApiTimeout& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					~CApiTimeout()
					{

					}

				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			シリアライズ
					////////////////////////////////////////////////////////////////////////////////
					friend class cereal::access;
					template<class T>
					void serialize(T& archive)
					{
						archive(cereal::make_nvp("Value", Value));
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			Json形式にシリアライズした文字列から更新
					/// @param[in]		object	Json形式にシリアライズした文字列
					////////////////////////////////////////////////////////////////////////////////
					void Input(std::string object)
					{
						// Json形式から変換
						Update(Archive::Input<CApiTimeout>(ConstHeader, object));
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			Json形式にシリアライズした文字列を取得
					/// @return			シリアライズした文字列
					////////////////////////////////////////////////////////////////////////////////
					std::string Output()
					{
						std::string ret;

						// Json形式に変換
						ret = Archive::Output<CApiTimeout>(ConstHeader, *this);

						return ret;
					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const CApiTimeout& object)
					{
						this->Value = object.Value;
					}

				public:
					//! Apiのタイムアウト[ms]
					long Value;
				};

				////////////////////////////////////////////////////////////////////////////////
				/// @class      CClose
				/// @brief      コントローラを閉じる設定クラス
				///				⇒ 識別子を保持するクラスから派生
				////////////////////////////////////////////////////////////////////////////////
				class CClose
					: virtual public CIdentifier
				{
				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					CClose()
					{

					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CClose& operator = (const CClose& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					~CClose()
					{

					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const CClose& object)
					{
						// 既定の関数
						CIdentifier::Update(object);
					}
				};
			}
		}
	}
}

// バイトアラインメントを戻す
#pragma pack()
