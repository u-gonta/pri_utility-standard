#pragma once

#include <map>

#include "Common/Signal/Define.h"
#include "Common/Iterator/Basis.h"
#include "Common/Archive/Convert.h"
#include "Identifier.h"

#include "cereal/types/map.hpp"

// 1バイトアラインメントに変更
#pragma pack(1)

namespace Standard
{
	namespace MotionApi
	{
		namespace Device
		{
			////////////////////////////////////////////////////////////////////////////////
			/// @enum			座標系
			////////////////////////////////////////////////////////////////////////////////
			enum EnumCoordinate
			{
				CoodinateWork = 0,			// ワーク座標系
				CoodinateMachine = 1		// 機械座標系
			};

			////////////////////////////////////////////////////////////////////////////////
			/// @enum			動作タイプ
			////////////////////////////////////////////////////////////////////////////////
			enum EnumMove
			{
				MoveRelative = 0,			// 増分値指定、直線軸or回転軸
				MoveAbsolute = 1,			// 絶対値指定、直線軸
				MoveRotaryShort = 2,		// 絶対値指定、回転軸(近回り)
				MoveRotaryPositive = 3,		// 絶対値指定、回転軸(正転)
				MoveRotaryNegative = 4		// 絶対値指定、回転軸(逆転)
			};

			////////////////////////////////////////////////////////////////////////////////
			/// @enum			速度タイプ
			////////////////////////////////////////////////////////////////////////////////
			enum EnumVelocity
			{
				VelocityUnit = 0,			// 速度[指令単位/sec]
				VelocityPercent = 1			// モータの定格回転数（定格速度）、または、送り最高速度の%指定(Velocity= 1のとき、0.01%)
			};

			////////////////////////////////////////////////////////////////////////////////
			/// @enum			加減速タイプ
			////////////////////////////////////////////////////////////////////////////////
			enum EnumAccDec
			{
				AccDecUnit = 0,				// 加減速度指定[指令単位/sec^2]
				AccDecTime = 1,				// 時定数指定[ms]
				AccDecKeep = 2				// 現在の設定を保持
			};

			////////////////////////////////////////////////////////////////////////////////
			/// @enum			加減速フィルタタイプ
			////////////////////////////////////////////////////////////////////////////////
			enum EnumFilter
			{
				FilterCurve = 0,			// 移動平均フィルタ（簡易S字）
				FilterExp = 1,				// 指数フィルタ
				FilterNothing = 2,			// フィルタなし
				FilterKeep = 3				// 現在の設定を保持
			};

			////////////////////////////////////////////////////////////////////////////////
			/// @enum			軸の方向
			////////////////////////////////////////////////////////////////////////////////
			enum EnumDirection
			{
				DirectionPositive = 0,		// 正方向
				DirectionNegative = 1		// 逆方向
			};

			////////////////////////////////////////////////////////////////////////////////
			/// @enum			完了の属性
			////////////////////////////////////////////////////////////////////////////////
			enum EnumComplete
			{
				CompleteDistribution = 0,	// 払い出し完了
				CompletePositioning = 1,	// 位置決め完了
				CompleteStart = 2			// 指令開始
			};

			////////////////////////////////////////////////////////////////////////////////
			/// @enum			ポジションのデータタイプ
			////////////////////////////////////////////////////////////////////////////////
			enum EnumPositionData
			{
				PositionImmediate = 0,		// 直接指定 ※ポジションデータを指定
				PositionIndirect = 1		// 関節指定 ※ポジションデータを格納しているレジスタハンドルを指定
			};

			////////////////////////////////////////////////////////////////////////////////
			/// @enum			原点復帰の方式
			////////////////////////////////////////////////////////////////////////////////
			enum EnumOrigin
			{
				OriginDec1_C = 0,			// DEC1 + C相パルス方式
				OriginZero = 1,				// ZERO信号方式
				OriginDec1_Zero = 2,		// DEC1 + ZERO信号方式
				OriginC = 3,				// C相パルス方式
				OriginDec2_Zero = 4,		// DEC2 + ZERO信号方式
				OriginDec1_L_Zero = 5,		// DEC1 + LMT + ZERO信号方式
				OriginDec2_C = 6,			// DEC2 + C相信号方式
				OriginDec1_L_C = 7,			// DEC1 + LMT + C相信号方式
				OriginC_Only = 8,			// 新C相パルス方式
				OriginPot_C = 9,			// POT & C相パルス方式
				OriginPot_Only = 10,		// POT方式
				OriginHomeLs_C = 11,		// HOME LS & C相パルス方式
				OriginHomeLs_Only = 12,		// HOME LS方式
				OriginNot_C = 13,			// NOT & C相パルス方式
				OriginNot_Only = 14,		// NOT方式
				OriginInput_C = 15,			// INPUT & C相パルス方式
				OriginInput_Only = 16		// INPUT方式
			};

			namespace Setting
			{
				////////////////////////////////////////////////////////////////////////////////
				/// @class      CTemplate
				/// @brief      設定するテンプレートのクラス
				////////////////////////////////////////////////////////////////////////////////
				class CTemplate
				{
				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					CTemplate()
					{
						Handle = 0;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CTemplate& operator = (const CTemplate& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					virtual ~CTemplate()
					{

					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const CTemplate& object)
					{
						this->Handle = object.Handle;
					}

				public:
					//! 機器のハンドル
					unsigned long Handle;
				};

				////////////////////////////////////////////////////////////////////////////////
				/// @class      CDeclare
				/// @brief      デバイスのハンドルを作成する設定クラス
				////////////////////////////////////////////////////////////////////////////////
				class CDeclare
				{
				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					CDeclare()
					{

					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CDeclare& operator = (const CDeclare& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					~CDeclare()
					{

					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const CDeclare& object)
					{
						this->Handles.clear();
						std::copy(object.Handles.begin(), object.Handles.end(), std::back_inserter(this->Handles));
					}

				public:
					//! 軸のハンドル
					std::vector<unsigned long> Handles;
				};

				////////////////////////////////////////////////////////////////////////////////
				/// @class      CClear
				/// @brief      デバイスのハンドルを破棄する設定クラス
				///				⇒ 識別子を保持するクラスから派生
				////////////////////////////////////////////////////////////////////////////////
				class CClear
					: virtual public CIdentifier
				{
				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					CClear()
					{

					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CClear& operator = (const CClear& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					~CClear()
					{

					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const CClear& object)
					{
						// 既定の関数
						CIdentifier::Update(object);
					}
				};

				namespace Suspend
				{
					////////////////////////////////////////////////////////////////////////////////
					/// @class      CAxis
					/// @brief      制御を停止する軸の設定クラス
					///				⇒ 識別子を保持するクラスから派生
					////////////////////////////////////////////////////////////////////////////////
					class CAxis
						: virtual public CIdentifier
					{
					public:
						////////////////////////////////////////////////////////////////////////////////
						/// @brief			コンストラクタ
						////////////////////////////////////////////////////////////////////////////////
						CAxis() : CIdentifier()
						{
							Address = 0;
						}

						////////////////////////////////////////////////////////////////////////////////
						/// @brief			コピー代入演算子
						/// @return			自クラス
						////////////////////////////////////////////////////////////////////////////////
						CAxis& operator = (const CAxis& object) noexcept
						{
							// 更新
							Update(object);

							return *this;
						}

						////////////////////////////////////////////////////////////////////////////////
						/// @brief			デストラクタ
						////////////////////////////////////////////////////////////////////////////////
						~CAxis()
						{

						}

					protected:
						////////////////////////////////////////////////////////////////////////////////
						/// @brief			自クラスを更新
						/// @param[in]		object	自クラス
						////////////////////////////////////////////////////////////////////////////////
						void Update(const CAxis& object)
						{
							// 既定の関数
							CIdentifier::Update(object);

							this->Address = object.Address;
						}

					public:
						//! 軸のレジスタ先頭アドレス
						unsigned short Address;
					};
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @class      CSuspend
				/// @brief      制御の停止を設定するクラス
				///				⇒ 識別子を保持するクラスから派生
				////////////////////////////////////////////////////////////////////////////////
				class CSuspend
					: virtual public CIdentifier
				{
				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					CSuspend() : CIdentifier()
					{

					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CSuspend& operator = (const CSuspend& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					~CSuspend()
					{

					}

				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デバイスのハンドルを作成する設定クラスを取得
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					CDeclare GetDeclare()
					{
						CDeclare ret;

						// 軸を走査
						for (const auto& axis : Axises)
						{
							// ハンドルを追加
							ret.Handles.emplace_back(axis.Handle);
						}

						return ret;
					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const CSuspend& object)
					{
						// 既定の関数
						CIdentifier::Update(object);

						this->Axises.clear();
						std::copy(object.Axises.begin(), object.Axises.end(), std::back_inserter(this->Axises));
					}

				public:
					//! 制御を停止する軸の状態クラス
					std::vector<Suspend::CAxis> Axises;
				};

				////////////////////////////////////////////////////////////////////////////////
				/// @class      CServo
				/// @brief      サーボの制御を行う設定クラス
				///				⇒ 識別子を保持するクラスから派生
				////////////////////////////////////////////////////////////////////////////////
				class CServo
					: virtual public CIdentifier, virtual public CDeclare
				{
				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					CServo() : CIdentifier(), CDeclare()
					{
						Mode = Signal::StatusOff;
						Timeout = 5000;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CServo& operator = (const CServo& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					~CServo()
					{

					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const CServo& object)
					{
						// 既定の関数
						CIdentifier::Update(object);
						CDeclare::Update(object);

						this->Mode = object.Mode;
						this->Timeout = object.Timeout;
					}

				public:
					//! サーボの状態
					Signal::EnumStatus Mode;

					//! タイムアウト[ms]
					unsigned short Timeout;
				};

				namespace Motion
				{
					////////////////////////////////////////////////////////////////////////////////
					/// @class      CContent
					/// @brief      モーションのデータを保持するクラス
					////////////////////////////////////////////////////////////////////////////////
					class CContent
					{
					public:
						////////////////////////////////////////////////////////////////////////////////
						/// @brief			コンストラクタ
						////////////////////////////////////////////////////////////////////////////////
						CContent()
						{
							Indirect = true;
							Value = 0;
						}

						////////////////////////////////////////////////////////////////////////////////
						/// @brief			コピー代入演算子
						/// @return			自クラス
						////////////////////////////////////////////////////////////////////////////////
						CContent& operator = (const CContent& object) noexcept
						{
							// 更新
							Update(object);

							return *this;
						}

						////////////////////////////////////////////////////////////////////////////////
						/// @brief			デストラクタ
						////////////////////////////////////////////////////////////////////////////////
						~CContent()
						{

						}

					protected:
						////////////////////////////////////////////////////////////////////////////////
						/// @brief			自クラスを更新
						/// @param[in]		object	自クラス
						////////////////////////////////////////////////////////////////////////////////
						void Update(const CContent& object)
						{
							this->Indirect = object.Indirect;
							this->Value = object.Value;
						}

					public:
						//! 関節指定
						bool Indirect;

						//! データの値
						unsigned long Value;
					};

					////////////////////////////////////////////////////////////////////////////////
					/// @class      CTemplate
					/// @brief      モーションの設定を保持するテンプレートのクラス
					////////////////////////////////////////////////////////////////////////////////
					class CTemplate
					{
					public:
						////////////////////////////////////////////////////////////////////////////////
						/// @brief			コンストラクタ
						////////////////////////////////////////////////////////////////////////////////
						CTemplate()
						{
							Coordinate = CoodinateMachine;
							MoveType = MoveAbsolute;
							VelocityType = VelocityUnit;
							AccDecType = AccDecKeep;
							FilterType = FilterKeep;
						}

						////////////////////////////////////////////////////////////////////////////////
						/// @brief			コピー代入演算子
						/// @return			自クラス
						////////////////////////////////////////////////////////////////////////////////
						CTemplate& operator = (const CTemplate& object) noexcept
						{
							// 更新
							Update(object);

							return *this;
						}

						////////////////////////////////////////////////////////////////////////////////
						/// @brief			デストラクタ
						////////////////////////////////////////////////////////////////////////////////
						~CTemplate()
						{

						}

					public:
						////////////////////////////////////////////////////////////////////////////////
						/// @brief			関節指定のデータをレジスタの先頭アドレスからの値に更新
						/// @param[in]		address	レジスタの先頭アドレス
						////////////////////////////////////////////////////////////////////////////////
						void Reflection(unsigned short address)
						{
							// 速度の上限値、送り最高速度
							if (MaxVelocity.Indirect)
							{
								MaxVelocity.Value = address + 0x10;
							}

							// 加速度[指令単位/sec^2]／加速時定数[ms]
							if (Acceleration.Indirect)
							{
								Acceleration.Value = address + 0x36;
							}

							// 減速度[指令単位/sec^2]／減速時定数[ms]
							if (Deceleration.Indirect)
							{
								Deceleration.Value = address + 0x38;
							}

							// フィルタ時間 ※0.1[ms]
							if (FilterTime.Indirect)
							{
								FilterTime.Value = address + 0x3A;
							}

							// 速度
							if (Velocity.Indirect)
							{
								Velocity.Value = address + 0x10;
							}

							// 原点復帰のアプローチ速度
							if (ApproachVelocity.Indirect)
							{
								ApproachVelocity.Value = address + 0x3E;
							}

							// 原点復帰のクリープ速度
							if (CreepVelocity.Indirect)
							{
								CreepVelocity.Value = address + 0x40;
							}
						}

					protected:
						////////////////////////////////////////////////////////////////////////////////
						/// @brief			自クラスを更新
						/// @param[in]		object	自クラス
						////////////////////////////////////////////////////////////////////////////////
						void Update(const CTemplate& object)
						{
							this->Coordinate = object.Coordinate;
							this->MoveType = object.MoveType;
							this->VelocityType = object.VelocityType;
							this->AccDecType = object.AccDecType;
							this->FilterType = object.FilterType;
							this->MaxVelocity = object.MaxVelocity;
							this->Acceleration = object.Acceleration;
							this->Deceleration = object.Deceleration;
							this->FilterTime = object.FilterTime;
							this->Velocity = object.Velocity;
							this->ApproachVelocity = object.ApproachVelocity;
							this->CreepVelocity = object.CreepVelocity;
						}

					public:
						//! 座標系
						EnumCoordinate Coordinate;

						//! 動作タイプ
						EnumMove MoveType;

						//! 速度タイプ
						EnumVelocity VelocityType;

						//! 加減速タイプ
						EnumAccDec AccDecType;

						//! 加減速フィルタタイプ
						EnumFilter FilterType;

						//! 速度の上限値、送り最高速度
						CContent MaxVelocity;

						//! 加速度[指令単位/sec^2]／加速時定数[ms]
						CContent Acceleration;

						//! 減速度[指令単位/sec^2]／減速時定数[ms]
						CContent Deceleration;

						//! フィルタ時間 ※0.1[ms]
						CContent FilterTime;

						//! 速度
						CContent Velocity;

						//! 原点復帰のアプローチ速度
						CContent ApproachVelocity;

						//! 原点復帰のクリープ速度
						CContent CreepVelocity;
					};
				}

				namespace Position
				{
					////////////////////////////////////////////////////////////////////////////////
					/// @class      CTemplate
					/// @brief      ポジションの設定を保持するテンプレートのクラス
					////////////////////////////////////////////////////////////////////////////////
					class CTemplate
					{
					public:
						////////////////////////////////////////////////////////////////////////////////
						/// @brief			コンストラクタ
						////////////////////////////////////////////////////////////////////////////////
						CTemplate()
						{
							PositionType = PositionIndirect;
							PositionData = 0;
						}

						////////////////////////////////////////////////////////////////////////////////
						/// @brief			コピー代入演算子
						/// @return			自クラス
						////////////////////////////////////////////////////////////////////////////////
						CTemplate& operator = (const CTemplate& object) noexcept
						{
							// 更新
							Update(object);

							return *this;
						}

						////////////////////////////////////////////////////////////////////////////////
						/// @brief			デストラクタ
						////////////////////////////////////////////////////////////////////////////////
						~CTemplate()
						{

						}

					protected:
						////////////////////////////////////////////////////////////////////////////////
						/// @brief			自クラスを更新
						/// @param[in]		object	自クラス
						////////////////////////////////////////////////////////////////////////////////
						void Update(const CTemplate& object)
						{
							this->PositionType = object.PositionType;
							this->PositionData = object.PositionData;
						}

					public:
						//! ポジションのタイプ
						EnumPositionData PositionType;

						//! ポジションのデータ
						long PositionData;
					};
				}

				namespace Origin
				{
					////////////////////////////////////////////////////////////////////////////////
					/// @class      CAxis
					/// @brief      軸の原点復帰を行う設定クラス
					///				⇒ 識別子を保持するクラスから派生
					///				⇒ モーションの設定を保持するテンプレートのクラスから派生
					///				⇒ ポジションの設定を保持するテンプレートのクラスから派生
					////////////////////////////////////////////////////////////////////////////////
					class CAxis
						: virtual public CIdentifier, virtual public Motion::CTemplate, virtual public Position::CTemplate
					{
					public:
						////////////////////////////////////////////////////////////////////////////////
						/// @brief			コンストラクタ
						////////////////////////////////////////////////////////////////////////////////
						CAxis() : CIdentifier(), Motion::CTemplate(), Position::CTemplate()
						{
							Method = OriginDec1_C;
							Direction = DirectionNegative;
							Complete = CompleteStart;
						}

						////////////////////////////////////////////////////////////////////////////////
						/// @brief			コピー代入演算子
						/// @return			自クラス
						////////////////////////////////////////////////////////////////////////////////
						CAxis& operator = (const CAxis& object) noexcept
						{
							// 更新
							Update(object);

							return *this;
						}

						////////////////////////////////////////////////////////////////////////////////
						/// @brief			デストラクタ
						////////////////////////////////////////////////////////////////////////////////
						~CAxis()
						{

						}

					protected:
						////////////////////////////////////////////////////////////////////////////////
						/// @brief			自クラスを更新
						/// @param[in]		object	自クラス
						////////////////////////////////////////////////////////////////////////////////
						void Update(const CAxis& object)
						{
							// 既定の関数
							CIdentifier::Update(object);
							Motion::CTemplate::Update(object);
							Position::CTemplate::Update(object);

							this->Method = object.Method;
							this->Direction = object.Direction;
							this->Complete = object.Complete;
						}

					public:
						//! 原点復帰の方式
						EnumOrigin Method;

						//! 移動する方向
						EnumDirection Direction;

						//! 完了の属性
						EnumComplete Complete;
					};
				}

				namespace Jog
				{
					////////////////////////////////////////////////////////////////////////////////
					/// @class      CStart
					/// @brief      ジョグの開始を行う設定クラス
					///				⇒ 識別子を保持するクラスから派生
					///				⇒ モーションの設定を保持するテンプレートのクラスから派生
					////////////////////////////////////////////////////////////////////////////////
					class CStart
						: virtual public CIdentifier, virtual public Motion::CTemplate
					{
					public:
						////////////////////////////////////////////////////////////////////////////////
						/// @brief			コンストラクタ
						////////////////////////////////////////////////////////////////////////////////
						CStart() : CIdentifier(), Motion::CTemplate()
						{
							Direction = DirectionPositive;
							Timeout = 0;
						}

						////////////////////////////////////////////////////////////////////////////////
						/// @brief			コピー代入演算子
						/// @return			自クラス
						////////////////////////////////////////////////////////////////////////////////
						CStart& operator = (const CStart& object) noexcept
						{
							// 更新
							Update(object);

							return *this;
						}

						////////////////////////////////////////////////////////////////////////////////
						/// @brief			デストラクタ
						////////////////////////////////////////////////////////////////////////////////
						~CStart()
						{

						}

					protected:
						////////////////////////////////////////////////////////////////////////////////
						/// @brief			自クラスを更新
						/// @param[in]		object	自クラス
						////////////////////////////////////////////////////////////////////////////////
						void Update(const CStart& object)
						{
							// 既定の関数
							CIdentifier::Update(object);
							Motion::CTemplate::Update(object);

							this->Direction = object.Direction;
							this->Timeout = object.Timeout;
						}

					public:
						//! 方向
						EnumDirection Direction;

						//! タイムアウト[ms]
						unsigned short Timeout;
					};

					////////////////////////////////////////////////////////////////////////////////
					/// @class      CStop
					/// @brief      ジョグの停止を行う設定クラス
					///				⇒ 識別子を保持するクラスから派生
					////////////////////////////////////////////////////////////////////////////////
					class CStop
						: virtual public CIdentifier
					{
					public:
						////////////////////////////////////////////////////////////////////////////////
						/// @brief			コンストラクタ
						////////////////////////////////////////////////////////////////////////////////
						CStop() : CIdentifier()
						{
							Complete = CompletePositioning;
						}

						////////////////////////////////////////////////////////////////////////////////
						/// @brief			コピー代入演算子
						/// @return			自クラス
						////////////////////////////////////////////////////////////////////////////////
						CStop& operator = (const CStop& object) noexcept
						{
							// 更新
							Update(object);

							return *this;
						}

						////////////////////////////////////////////////////////////////////////////////
						/// @brief			デストラクタ
						////////////////////////////////////////////////////////////////////////////////
						~CStop()
						{

						}

					protected:
						////////////////////////////////////////////////////////////////////////////////
						/// @brief			自クラスを更新
						/// @param[in]		object	自クラス
						////////////////////////////////////////////////////////////////////////////////
						void Update(const CStop& object)
						{
							// 既定の関数
							CIdentifier::Update(object);

							this->Complete = object.Complete;
						}

					public:
						//! 完了の属性
						EnumComplete Complete;
					};
				}

				////////////////////////////////////////////////////////////////////////////////
				/// @class      CMoveOrigin
				/// @brief      原点復帰を実行する設定クラス
				///				⇒ 識別子を保持するクラスから派生
				////////////////////////////////////////////////////////////////////////////////
				class CMoveOrigin
					: virtual public CIdentifier
				{
				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					CMoveOrigin() : CIdentifier()
					{
						Timeout = 30000;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CMoveOrigin& operator = (const CMoveOrigin& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					~CMoveOrigin()
					{

					}

				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デバイスのハンドルを作成する設定クラスを取得
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					CDeclare GetDeclare()
					{
						CDeclare ret;

						// 軸を走査
						for (const auto& axis : Axises)
						{
							// ハンドルを追加
							ret.Handles.emplace_back(axis.Handle);
						}

						return ret;
					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const CMoveOrigin& object)
					{
						// 既定の関数
						CIdentifier::Update(object);

						this->Axises.clear();
						std::copy(object.Axises.begin(), object.Axises.end(), std::back_inserter(this->Axises));
						this->Timeout = object.Timeout;
					}

				public:
					//! 軸の原点復帰を行う設定クラス
					std::vector<Origin::CAxis> Axises;

					//! タイムアウト[ms]
					unsigned short Timeout;
				};

				////////////////////////////////////////////////////////////////////////////////
				/// @class      CStartJog
				/// @brief      ジョグの開始を設定するクラス
				///				⇒ 識別子を保持するクラスから派生
				////////////////////////////////////////////////////////////////////////////////
				class CStartJog
					: virtual public CIdentifier
				{
				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					CStartJog() : CIdentifier()
					{

					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CStartJog& operator = (const CStartJog& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					~CStartJog()
					{

					}

				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デバイスのハンドルを作成する設定クラスを取得
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					CDeclare GetDeclare()
					{
						CDeclare ret;

						// 軸を走査
						for (const auto& axis : Axises)
						{
							// ハンドルを追加
							ret.Handles.emplace_back(axis.Handle);
						}

						return ret;
					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const CStartJog& object)
					{
						// 既定の関数
						CIdentifier::Update(object);

						this->Axises.clear();
						std::copy(object.Axises.begin(), object.Axises.end(), std::back_inserter(this->Axises));
					}

				public:
					//! ジョグの開始を行う設定クラス
					std::vector<Jog::CStart> Axises;
				};

				////////////////////////////////////////////////////////////////////////////////
				/// @class      CStopJog
				/// @brief      ジョグの停止を設定するクラス
				///				⇒ 識別子を保持するクラスから派生
				////////////////////////////////////////////////////////////////////////////////
				class CStopJog
					: virtual public CIdentifier
				{
				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コンストラクタ
					////////////////////////////////////////////////////////////////////////////////
					CStopJog() : CIdentifier()
					{

					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			コピー代入演算子
					/// @return			自クラス
					////////////////////////////////////////////////////////////////////////////////
					CStopJog& operator = (const CStopJog& object) noexcept
					{
						// 更新
						Update(object);

						return *this;
					}

					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デストラクタ
					////////////////////////////////////////////////////////////////////////////////
					~CStopJog()
					{

					}

				public:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			デバイスのハンドルを作成する設定クラスを取得
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					CDeclare GetDeclare()
					{
						CDeclare ret;

						// 軸を走査
						for (const auto& axis : Axises)
						{
							// ハンドルを追加
							ret.Handles.emplace_back(axis.Handle);
						}

						return ret;
					}

				protected:
					////////////////////////////////////////////////////////////////////////////////
					/// @brief			自クラスを更新
					/// @param[in]		object	自クラス
					////////////////////////////////////////////////////////////////////////////////
					void Update(const CStopJog& object)
					{
						// 既定の関数
						CIdentifier::Update(object);

						this->Axises.clear();
						std::copy(object.Axises.begin(), object.Axises.end(), std::back_inserter(this->Axises));
					}

				public:
					//! 軸のジョグ停止を行う設定クラス
					std::vector<Jog::CStop> Axises;
				};
			}
		}
	}
}

// バイトアラインメントを戻す
#pragma pack()
